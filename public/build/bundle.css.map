{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\..\\src\\components\\DashNav.svelte",
    "..\\..\\src\\components\\Dash.svelte",
    "..\\..\\src\\components\\WidgetMenu.svelte",
    "..\\..\\node_modules\\svelte-grid\\src\\index.svelte",
    "..\\..\\src\\components\\buttons\\Left.svelte",
    "..\\..\\src\\components\\buttons\\Right.svelte",
    "..\\..\\src\\components\\buttons\\Add.svelte",
    "..\\..\\src\\components\\buttons\\Trash.svelte",
    "..\\..\\src\\components\\widgets\\Widget.svelte",
    "..\\..\\src\\components\\widgets\\Sticky.svelte",
    "..\\..\\src\\components\\widgets\\stickyTypes\\Text.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n    import { getActiveDash } from '../dataStore';\r\n    import Left from './buttons/Left.svelte';\r\n    import Right from './buttons/Right.svelte';\r\n    import Trash from './buttons/Trash.svelte';\r\n    import Add from './buttons/Add.svelte';\r\n    let _title = getActiveDash()._title;\r\n    let editingTitle = false;\r\n</script>\r\n\r\n<nav>\r\n    <Left />\r\n    <Trash />\r\n    <div>\r\n        {#if editingTitle}\r\n            <input bind:value={$_title} on:blur={() => editingTitle = false} type=\"text\" autofocus />\r\n        {:else}\r\n            <a class=\"active-dash-title\" on:click={() => editingTitle = true}>{$_title}</a>\r\n        {/if}\r\n    </div>\r\n    <Add />\r\n    <Right />\r\n</nav>\r\n\r\n<style>\r\nnav {\r\n    display: grid;\r\n    grid-template-columns: auto 70px auto 70px auto 70px auto 70px auto;\r\n    grid-template-areas: \". left . trash bar add . right .\";\r\n    grid-template-rows: 70px auto;\r\n    margin-bottom: 70px;\r\n}\r\ndiv {\r\n    overflow: hidden;\r\n    grid-area: bar;\r\n    border: solid 1px #707070;\r\n    display: flex;\r\n    flex-flow: row nowrap;\r\n    align-items: center;\r\n    justify-content: center; /* will need to change when we add dashes */\r\n}\r\n.active-dash-title, input {\r\n    text-decoration: none;\r\n    color: #707070;\r\n    font-size: 32px;\r\n    padding: 0;\r\n    margin: 0;\r\n    text-align: center;\r\n    white-space: nowrap;\r\n    min-width: 120px;\r\n    height: 50px;\r\n}\r\n@media only screen and (max-width: 640px) {\r\n    nav {\r\n    display: grid;\r\n    grid-template-columns: auto 70px auto 70px auto 70px auto 70px auto;\r\n    grid-template-areas: \r\n    \". left . trash . add . right .\"\r\n    \". bar bar bar bar bar bar bar .\";\r\n    row-gap: 24px;\r\n    grid-template-rows: 70px 70px auto;\r\n    margin-bottom: 70px;\r\n}\r\n}\r\n</style>",
    "<script>\r\n  import { getActiveDash, getWidget, setWidgetSizeAndPos } from \"../dataStore\";\r\n  import { beforeUpdate } from 'svelte';\r\n  import Widget from \"./widgets/Widget.svelte\";\r\n  import Grid from \"svelte-grid\";\r\n  import gridHelp from \"svelte-grid/build/helper/index.mjs\";\r\n\r\n    //The array of grid elements\r\n  let items_arr = [];\r\n  let cols = 10;\r\n  let _widgetsCount = getActiveDash()._widgetsCount;\r\n  const updateWidgetSizeAndPos = item => {\r\n    const {w, h, x, y} = item;\r\n    setWidgetSizeAndPos(item.id, {w, h, x, y});\r\n  }\r\n   //Grid Layout\r\n  let widgets = [];\r\n    beforeUpdate(() => {\r\n      if ($_widgetsCount !== widgets.length) {\r\n        items_arr = [];\r\n        widgets = Array.from(getActiveDash().widgets.keys());\r\n        widgets.forEach((ref) => {\r\n          let {w, h, x, y} = getWidget(ref).sizeAndPos;\r\n          let newItem = gridHelp.item({\r\n            w,\r\n            h,\r\n            x,\r\n            y,\r\n            id: ref\r\n          });\r\n          items_arr = gridHelp.appendItem(newItem, items_arr, cols);\r\n        });\r\n        items_arr.forEach(item => {\r\n          updateWidgetSizeAndPos(item);\r\n        })\r\n      }\r\n  });\r\n</script>\r\n\r\n<Grid on:adjust={event => updateWidgetSizeAndPos(event.detail.focuesdItem)} items={items_arr} bind:items={items_arr} cols={cols} let:item rowHeight={100}>\r\n  <div class=\"content\" style=\"background: #ccc; border: 1px solid black;\">\r\n    <Widget ref={item.id} />\r\n  </div>\r\n</Grid>\r\n\r\n<style>\r\n  div {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n  .content {\r\n    width: 100%;\r\n    height: 100%;\r\n    color: black;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    font-size: large;\r\n  }\r\n  :global(.svlt-grid-shadow) {\r\n    background: pink;\r\n  }\r\n  :global(.svlt-grid-container) {\r\n    background: #eee;\r\n  }\r\n</style>",
    "<script>\r\n  import { addWidget } from '../dataStore.js';\r\n  import Add from './buttons/Add.svelte';\r\n  import Trash from './buttons/Trash.svelte';\r\n  let menuOpen = false;\r\n  let trashActive = false;\r\n  \r\n  const closeMenu = () => {\r\n    setTimeout(() => { \r\n      if (menuOpen) { // timeout and latch so runs after toggle\r\n        menuOpen = false;\r\n      }\r\n    }, 0);\r\n    window.removeEventListener('click', closeMenu, {capture : true});\r\n  }\r\n  const openMenu = () => {\r\n    menuOpen = true;\r\n    window.addEventListener('click', closeMenu, {capture : true});\r\n  }\r\n  const toggleMenu = () => {menuOpen ? closeMenu() : openMenu()};\r\n\r\n  const toggleTrash = () => {trashActive = !trashActive};\r\n\r\n  const add = type => {\r\n    addWidget(type);\r\n    closeMenu();\r\n  }\r\n</script>\r\n  \r\n<nav>\r\n  <Trash active={trashActive} on:trash={toggleTrash} on:trash /> <!-- the 2nd on:trash is to pass the event out to App -->\r\n    {#if menuOpen}\r\n      <img class=\"cancel\" src=\"/images/cancelIcon.svg\" alt=\"x\" />\r\n      <div>\r\n        <button on:click={() => add('Sticky')}>\r\n          <h3>Sticky</h3> \r\n          <img src=\"/images/addIcon.svg\" alt=\"+\" />\r\n        </button>\r\n      </div>\r\n    {/if}\r\n  <h2>Widgets</h2>\r\n  <Add active={menuOpen} on:add={toggleMenu} />\r\n</nav>\r\n  \r\n<style>\r\n  nav {\r\n    width: 280px;\r\n    position: fixed;\r\n    bottom: 5vh;\r\n    right: 5vw;\r\n    display: inline-grid;\r\n    grid-template-columns: 1fr 5fr 1fr;\r\n    grid-template-rows: auto auto 70px;\r\n    grid-template-areas: \r\n      \". . cancel\"\r\n      \"menu menu menu\"\r\n      \"trash title add\";\r\n    align-items: center;\r\n  }\r\n  div {\r\n    grid-area: menu;\r\n    border: solid 1px #707070;\r\n  }\r\n  .cancel {\r\n    grid-area: cancel;\r\n    place-self: center end;\r\n  }\r\n  button {\r\n    width: 100%;\r\n    display: inline-flex;\r\n    flex-flow: row nowrap;\r\n    align-items: center;\r\n    background: none;\r\n    border: none;\r\n  }\r\n  h3 {\r\n    width: 100%;\r\n    font-size: 32px;\r\n    font-weight: 300;\r\n    margin: 0;\r\n  }\r\n  h2 {\r\n    grid-area: title;\r\n    display: inline-grid;\r\n    place-items: center center;\r\n    height: 96%;\r\n    border: solid 1px #707070;\r\n    border-width: 1px 0 1px 0;\r\n    font-size: 32px;\r\n    font-weight: 300;\r\n    margin: 0;\r\n  }\r\n</style>",
    "<style>\n  :global(body) {\n    overflow: scroll;\n  }\n\n .svlt-grid-container {\n  position: relative;\n}\n\n.svlt-grid-item {\n  touch-action:none;\n  position: absolute;\n}\n\n.svlt-grid-shadow {\n  position: absolute;\n}\n\n\n.svlt-grid-resizer {\n  user-select: none;\n  width: 20px;\n  height: 20px; \n  position:absolute; \n  right: 0; \n  bottom: 0; \n  cursor: se-resize; \n}\n\n.svlt-grid-resizer::after {\n  content: \"\";\n  position: absolute;\n  right: 3px;\n  bottom: 3px;\n  width: 5px;\n  height: 5px;\n  border-right: 2px solid rgba(0, 0, 0, 0.4);\n  border-bottom: 2px solid rgba(0, 0, 0, 0.4);\n}\n</style>\n\n<svelte:window on:resize={ debounce(onResize,300) } />\n\n<div class:svlt-grid-transition={!focuesdItem} class=svlt-grid-container bind:this={container} style=\"height: {ch}px\">\n  {#each items as item, i (item.id)}\n\n    <div on:mousedown={item.draggable ? dragOnMouseDown.bind(this, item.id) : null}\n        on:touchstart={item.draggable ? dragOnMouseDown.bind(this, item.id) : null}\n        class=svlt-grid-item style=\"{useTransform ? `transform: translate(${item.drag.dragging ? item.drag.left : (item.x * xPerPx) + gap}px, ${item.drag.dragging ? item.drag.top : (item.y * yPerPx + gap)}px);` : ''};\n        {!useTransform ? `top: ${item.drag.dragging ? item.drag.top : (item.y * yPerPx) + gap}px` : ''};\n        {!useTransform ? `left: ${item.drag.dragging ? item.drag.left : (item.x * xPerPx) + gap}px` : ''};\n        width: {item.resize.resizing ? item.resize.width : ((item.w * xPerPx) - gap * 2) - (item.responsive.valueW*xPerPx)}px;\n        height: {item.resize.resizing ? item.resize.height : (item.h * yPerPx) - gap * 2}px;\n        z-index: {item.drag.dragging || item.resize.resizing ? 3 : 1};\n        opacity: {item.resize.resizing ? 0.5 : 1}\">\n\n          <slot {item} index={i}></slot>\n          {#if item.resizable}\n            <div class=svlt-grid-resizer \n          on:touchstart={resizeOnMouseDown.bind(this,item.id)} \n          on:mousedown={resizeOnMouseDown.bind(this,item.id)}\n          ></div>\n          {/if}\n        </div>\n\n\n  {/each}\n\n  {#if shadow.active}\n    <div class=svlt-grid-shadow style=\"{useTransform ? `transform: translate(${shadow.drag.dragging ? shadow.drag.left : (shadow.x * xPerPx) + gap}px, ${shadow.drag.dragging ? shadow.drag.top : (shadow.y * yPerPx + gap)}px);` : ''};\n        {!useTransform ? `top: ${shadow.drag.dragging ? shadow.drag.top : (shadow.y * yPerPx) + gap}px` : ''};\n        {!useTransform ? `left: ${shadow.drag.dragging ? shadow.drag.left : (shadow.x * xPerPx) + gap}px` : ''};\n    width:{((shadow.w * xPerPx) - gap * 2) - (shadow.responsive.valueW*xPerPx)}px;\n    height:{(shadow.h * yPerPx) - gap * 2}px;\"></div>\n  {/if}\n</div>\n\n<script>\nimport { onMount, beforeUpdate,createEventDispatcher } from \"svelte\";\n\nimport { resizeItems, getItemById, moveItem, findFreeSpaceForItem } from \"./utils/item.js\";\nimport { getContainerHeight } from \"./utils/container.js\";\nimport { debounce, getRowsCount, getColumnFromBreakpoints, getCordinates, getTranslate } from \"./utils/other.js\";\nimport { makeMatrixFromItemsIgnore } from \"./utils/matrix.js\";\n\nexport let useTransform = false;\nexport let items = [];\nexport let cols = 0;\nexport let dragDebounceMs = 350;\nexport let gap = 0;\nexport let rowHeight = 150;\nexport let breakpoints;\nexport let fillEmpty = true;\n\nlet container,\n  focuesdItem,\n  bound,\n  xPerPx,\n  currentItemIndex,\n  getComputedCols,\n  documentWidth,\n  resizeNoDynamicCalc,\n  yPerPx = rowHeight,\n  initCols = cols,\n  shadow = {\n    w: 0,\n    h: 0,\n    x: 0,\n    y: 0,\n    active: false,\n    id: null,\n    responsive: { valueW: 0 },\n    min: {},\n    max: {}\n  },\n  ch = getContainerHeight(items, yPerPx);\n\nconst dispatch = createEventDispatcher();\n\nconst getDocWidth = () => document.documentElement.clientWidth\n\nfunction onResize() {\n\n  let w = document.documentElement.clientWidth\n\n  if(w !== documentWidth) {\n    documentWidth = w;\n    \n    bound = container.getBoundingClientRect();\n\n    let getCols = getColumnFromBreakpoints(breakpoints,w,cols,initCols)\n    \n    getComputedCols = getCols\n\n    xPerPx = bound.width / getCols\n\n    dispatch('resize', {\n      cols:getCols,\n      xPerPx,\n      yPerPx // same as rowHeight\n    });\n\n    if(breakpoints) {\n    \titems = resizeItems(items, getCols);\n    }\n\n  } \n\n}\n\n\nonMount(() => {\n  bound = container.getBoundingClientRect();\n\n  let getCols = getColumnFromBreakpoints(breakpoints, getDocWidth(), cols, initCols)\n  \n  getComputedCols = getCols\n\n  documentWidth = document.documentElement.clientWidth\n\n  if(breakpoints) {\n    items = resizeItems(items, getCols)\n  }\n\n  xPerPx = bound.width / getCols\n\n  dispatch('mount', {\n    cols: getCols,\n    xPerPx,\n    yPerPx // same as rowHeight\n  })\n\n});\n\n// resize\n\nlet resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;\n\nfunction resizeOnMouseDown(id, e) {\n  e.stopPropagation();\n\n  let {pageX,pageY} = getCordinates(e)\n\n  const { item, index } = getItemById(id, items);\n\n  currentItemIndex = index;\n\n  focuesdItem = item;\n\n  cacheItem = {...item}\n\n  resizeNoDynamicCalc = item.h + item.y === getRowsCount(items);\n\n  shadow = {...shadow,...focuesdItem,...{active:true}}\n\n  resizeStartX = pageX - bound.x;\n  resizeStartY = pageY - bound.y;\n\n  resizeStartWidth = (item.w * xPerPx) - (gap * 2) - (focuesdItem.responsive.valueW * xPerPx);\n\n  resizeStartHeight = (item.h * yPerPx) - (gap * 2);\n\n  getComputedCols = getColumnFromBreakpoints(breakpoints, getDocWidth(), cols, initCols)\n\n  window.addEventListener(\"mousemove\", resizeOnMouseMove, false);\n  window.addEventListener(\"touchmove\", resizeOnMouseMove, false);\n\n  window.addEventListener(\"mouseup\", resizeOnMouseUp, false);\n  window.addEventListener(\"touchend\", resizeOnMouseUp, false);\n}\n\nfunction resizeOnMouseMove(e) {\n\n  let {pageX,pageY}=getCordinates(e);\n\n  pageX = pageX - bound.x;\n  pageY = pageY - bound.y;\n\n  const height = resizeStartHeight + pageY - resizeStartY;\n  const width = resizeStartWidth + (pageX - resizeStartX)\n\n  const {responsive:{valueW} } = focuesdItem;\n\n  let wRes = Math.round(width / xPerPx) + valueW\n\n  const {h:minHeight=1,w:minWidth=1} = focuesdItem.min\n  const {h:maxHeight,w:maxWidth = ((getComputedCols - focuesdItem.x)+valueW)} = focuesdItem.max\n\n  wRes = Math.min(Math.max(wRes,minWidth),maxWidth)/* min max*/\n\n  let hRes = Math.round(height/yPerPx)\n  if(maxHeight) {\n    hRes = Math.min(hRes,maxHeight)\n  }\n  hRes = Math.max(hRes,minHeight)\n\n  shadow = {...shadow, ...{w:wRes, h:hRes}} \n\n  let assignItem = items[currentItemIndex]\n  items[currentItemIndex] = {\n    ...assignItem,\n    resize: {\n      resizing:true,\n      width,\n      height\n    },\n    w:wRes,\n    h:hRes\n  }\n\n  if (!resizeNoDynamicCalc) {\n    debounceRecalculateGridPosition();\n  }\n}\n\nfunction resizeOnMouseUp(e) {\n  e.stopPropagation();\n\n  let assignItem = items[currentItemIndex]\n  items[currentItemIndex] = {\n    ...assignItem,\n    resize:{\n      resizing:false,\n      width:0,\n      height:0\n    }\n  }\n\n  window.removeEventListener(\"mousemove\", resizeOnMouseMove, false);\n  window.removeEventListener(\"touchmove\", resizeOnMouseMove, false);\n\n  window.removeEventListener(\"mouseup\", resizeOnMouseUp, false);\n  window.removeEventListener(\"touchend\", resizeOnMouseUp, false);\n\n  shadow = {...shadow, ... {w:0,h:0,x:0,y:0,active:false,id:null,responsive:{valueW:0}}, min:{},max:{} } \n\n  recalculateGridPosition(\"up\");\n\n  focuesdItem = undefined;\n  resizeNoDynamicCalc = false;\n}\n\n// drag\nlet dragX = 0,\n  dragY = 0;\n\nconst debounceRecalculateGridPosition = debounce(recalculateGridPosition, dragDebounceMs);\n\nlet cacheItem = {};\n\nfunction dragOnMouseDown(id, e) {\n  e.stopPropagation()\n  let {pageX,pageY} = getCordinates(e)\n\n  const { item, index } = getItemById(id, items);\n  \n  currentItemIndex = index;\n\n\n  focuesdItem = item;\n  cacheItem = {...item}\n  \n  shadow = { ...shadow, ...item, active: true }; \n\n  \n\n  let { currentTarget } = e;\n\n  let offsetLeft, offsetTop;\n\n  if(useTransform) {\n    const { x, y } = getTranslate(currentTarget.style.transform)\n    offsetLeft = x\n    offsetTop = y\n  } else {\n    offsetLeft = currentTarget.offsetLeft\n    offsetTop = currentTarget.offsetTop\n  }\n\n  pageX = pageX - bound.x;\n  pageY = pageY - bound.y;\n\n  dragX = pageX - offsetLeft;\n\n  dragY = pageY - offsetTop;\n\n  getComputedCols = getColumnFromBreakpoints(breakpoints, getDocWidth(), cols, initCols)\n\n\n  if (item) {\n    window.addEventListener(\"mousemove\", dragOnMove, false);\n    window.addEventListener(\"touchmove\", dragOnMove, false);\n\n    window.addEventListener(\"mouseup\", dragOnMouseUp, false);\n    window.addEventListener(\"touchend\", dragOnMouseUp, false);\n  } else {\n    console.warn(\"Can not get item\");\n  }\n}\n\n\nfunction dragOnMove(e) {\n  e.stopPropagation()\n\n  let {pageX,pageY} = getCordinates(e)\n\n  const y = pageY - bound.y;\n  const x = pageX - bound.x;\n\n  let xRes = Math.round((x - dragX) / xPerPx);\n  let yRes = Math.round((y - dragY) / yPerPx);\n\n  xRes = Math.max(Math.min(xRes,getComputedCols-(focuesdItem.w- focuesdItem.responsive.valueW)),0)\n\n  yRes = Math.max(yRes, 0);\n\n  let assignItem = items[currentItemIndex];\n\n  items[currentItemIndex] = {\n    ...assignItem,\n    drag:{\n      dragging:true,\n      top:y - dragY,\n      left:x - dragX\n    },\n    x:xRes,\n    y:yRes\n  }\n\n  shadow = {...shadow, ...{x:xRes,y:yRes}}\n\n  debounceRecalculateGridPosition();\n}\n\nfunction dragOnMouseUp(e) {\n  window.removeEventListener(\"mousemove\", dragOnMove, false);\n  window.removeEventListener(\"touchmove\", dragOnMove, false);\n\n  window.removeEventListener(\"mouseup\", dragOnMouseUp, false);\n  window.removeEventListener(\"touchend\", dragOnMouseUp, false);\n\n  let assignItem = items[currentItemIndex]\n  items[currentItemIndex] = {\n    ...assignItem,\n    drag: {\n      dragging: false,\n      top: 0,\n      left: 0\n    },\n  }\n\n  dragX = 0;\n  dragY = 0;\n\n  shadow = {...shadow, ...{w:0,h:0,x:0,y:0,active:false,id:null}} \n  \n  recalculateGridPosition(\"up\");\n\n  focuesdItem = undefined;\n}\n\n\n// Will work on this, need to make code cleaner\nfunction recalculateGridPosition(action) {\n  const dragItem = items[currentItemIndex];\n\n  let getCols = getColumnFromBreakpoints(breakpoints, getDocWidth(), cols, initCols)\n  let result = moveItem(dragItem, items, getCols, cacheItem);\n\n  if(fillEmpty) {\n\n    result.forEach(value => {\n      if (value.id !== dragItem.id) {\n        result = result.map($val =>\n          $val.id === value.id\n            ? {\n                ...$val,\n                ...findFreeSpaceForItem(\n                  makeMatrixFromItemsIgnore(result, [value.id], getRowsCount(result), getCols),\n                  value,\n                  result\n                )\n              }\n            : $val\n        );\n      }\n    });\n  }\n\n  items = result\n\n  dispatch('adjust', {\n    focuesdItem: dragItem\n  });\n\n}\n\nbeforeUpdate(() => {\n  if (!focuesdItem) {\n    ch = getContainerHeight(items, yPerPx);\n    if(cols !== initCols) {\n      if(bound) {\n        xPerPx = bound.width/cols\n        initCols = cols\n      }\n    }\n  }\n});\n\n\n</script>\n",
    "<script>\r\n\r\n</script>\r\n\r\n<button>\r\n    <img src=\"/images/arrowRightIcon.svg\" alt=\"prev\" />\r\n</button>\r\n\r\n<style>\r\nbutton {\r\n    grid-area: left;\r\n    min-width: 100%;\r\n    min-height: 100%;\r\n    width: 68px;\r\n    height: 68px;\r\n    background: none;\r\n    border: none;\r\n    transform: rotate(180deg);\r\n}\r\n</style>",
    "<script>\r\n\r\n</script>\r\n\r\n<button>\r\n    <img src=\"/images/arrowRightIcon.svg\" alt=\"next\" />\r\n</button>\r\n\r\n<style>\r\n button {\r\n    grid-area: right;\r\n    min-height: 100%;\r\n    width: 68px;\r\n    height: 68px;\r\n    background: none;\r\n    border: none;\r\n}\r\n</style>",
    "\r\n<script>\r\n    import { createEventDispatcher } from 'svelte';\r\n    export let active;\r\n    const dispatch = createEventDispatcher();\r\n    const add = () => dispatch('add');\r\n</script>\r\n\r\n<button class=\"{active ? 'active' : ''}\" on:click={add}>\r\n    <img src=\"/images/addIcon.svg\" alt=\"+\" />\r\n</button>\r\n\r\n<style>\r\n\tbutton {\r\n        grid-area: add;\r\n        min-width: 100%;\r\n        min-height: 100%;\r\n        width: 68px;\r\n        height: 68px;\r\n\r\n        border: solid 1px #707070;\r\n        margin: 0;\r\n        background: none;\r\n    }\r\n    .active {\r\n        background: #707070;\r\n    }\r\n</style>",
    "\r\n<script>\r\n    import { createEventDispatcher } from 'svelte';\r\n    export let active;\r\n    const dispatch = createEventDispatcher();\r\n    const trash = () => {\r\n        dispatch('trash', {\r\n\t\t\tactive: !active // not sure why this inverts\r\n\t\t});\r\n    } \r\n</script>\r\n\r\n{#if active}\r\n<img class=\"cancel\" on:click={trash} src=\"/images/cancelIcon.svg\" alt=\"x\" />\r\n{/if}\r\n<button class=\"{active ? 'active' : ''}\" on:click={trash}><img src=\"/images/TrashIcon.svg\" alt=\"-\" /></button>\r\n\r\n<style>\r\n\tbutton {\r\n        grid-area: trash;\r\n        min-width: 100%;\r\n        min-height: 100%;\r\n        width: 68px;\r\n        height: 68px;\r\n        border: solid 1px #707070;\r\n        margin: 0;\r\n        background: #ffffff;\r\n    }\r\n    .active {\r\n        background: #707070;\r\n    }\r\n</style>",
    "<script>\r\n    import { getWidget, activeDashId ,removeWidget} from '../../dataStore';\r\n    import Sticky from './Sticky.svelte';\r\n    import Trash from '../buttons/Trash.svelte';\r\n    export let ref;\r\n    let {_title, _data, type} = getWidget(ref);\r\n    let editingTitle = false;\r\n    const removeSelf = () => {\r\n      removeWidget(ref);\r\n    }\r\n</script>\r\n\r\n<div>\r\n  {#if editingTitle}\r\n    <input bind:value={$_title} on:blur={() => editingTitle = false} type=\"text\" autofocus />\r\n  {:else}\r\n    <h2 on:click={() => editingTitle = true}>{$_title}</h2>\r\n  {/if}\r\n  {#if type === 'Sticky'}\r\n      <Sticky {_data} />\r\n      {:else}\r\n      <div>{type} Widget type not yet implemented</div>\r\n  {/if}\r\n  <span><Trash on:trash={removeSelf} /></span>\r\n</div>\r\n\r\n<style>\r\n  div {\r\n    display: grid;\r\n    place-items: start center;\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    padding: 12px;\r\n    box-sizing: border-box;\r\n  }\r\n  h2, input {\r\n    text-decoration: none;\r\n    color: #707070;\r\n    font-size: 32px;\r\n    padding: 0;\r\n    margin: 0;\r\n    text-align: center;\r\n    white-space: nowrap;\r\n    width: 100%;\r\n    height: 50px;\r\n    background: none;\r\n    font-weight: 400;\r\n  }\r\n  span {\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: 0;\r\n    visibility: hidden;\r\n  }\r\n  :global(.trash) span {\r\n    visibility: visible;\r\n  }\r\n  \r\n</style>\r\n",
    "<script>\r\n    import { getWidget } from '../../dataStore';\r\n    import { beforeUpdate } from 'svelte';\r\n    import Text from './stickyTypes/Text.svelte';\r\n    import detectInputType from '../../utils/detectInputType.js';\r\n    export let _data;\r\n    let type;\r\n    beforeUpdate(() => {\r\n\t\ttype = detectInputType($_data);\r\n\t});\r\n</script>\r\n\r\n{#if type === 'Text'}\r\n    <Text {_data} />\r\n{:else}\r\n    <textarea bind:value={$_data} />\r\n{/if}\r\n\r\n<style>\r\n    textarea {\r\n      width: 90%;\r\n    }\r\n</style>\r\n",
    "\r\n<script>\r\n\texport let _data;\r\n\tlet editing = true;\r\n</script>\r\n\r\n{#if editing}\r\n\t<textarea bind:value={$_data} on:blur={() => editing = false} autofocus />\r\n{:else}\r\n\t<article on:click={() => editing = true}>{$_data}</article>\r\n{/if}\r\n\r\n<style>\r\n\ttextarea, article {\r\n\t\twidth: 90%;\r\n\t\tbackground: none;\r\n\t\tpadding: 0;\r\n\t\tmargin: 0;\r\n\t}\r\n</style>"
  ],
  "names": [],
  "mappings": "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"
}